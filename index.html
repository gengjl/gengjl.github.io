<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you love,Love what you do!"><meta name="keywords" content="大前端,后端,中台,微服务,云原生,企业应用,数字化企业转型等"><meta name="author" content="Garin"><meta name="copyright" content="Garin"><title>进步不是什么事件，而是一种需要。 | 技术之美</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="技术之美" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Garin</div><div class="author-info__description text-center">Do what you love,Love what you do!</div><div class="follow-button"><a href="https://github.com/gengjl">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/Jolyon">gitee</a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">技术之美</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">技术之美</div><div id="site-sub-title">进步不是什么事件，而是一种需要。</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/04/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/">数据表结构的设计与性能优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">数据库设计</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">SQL性能优化</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DB%E6%9C%8D%E5%8A%A1/">DB服务</a></span><div class="content"><h1 id="1-数据表结构的设计与性能优化"><a href="#1-数据表结构的设计与性能优化" class="headerlink" title="1    数据表结构的设计与性能优化"></a>1    数据表结构的设计与性能优化</h1><h2 id="1-1-、数据表的存储原理"><a href="#1-1-、数据表的存储原理" class="headerlink" title="1.1  、数据表的存储原理"></a>1.1  、数据表的存储原理</h2><p>SQL Server每次读取1个存储块，每个存储块大小为8KB，每读取1个存储块计算为1个逻辑读。</p>
<p>问题：如果数据内容非常大，像我们系统中的Feeling字段非常大，就会导致每个存储块存放的数据行数会非常少，这样当我们读取数据时，要读取许多的存储块。</p>
<p><strong>存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>存储块**</strong>2**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<h2 id="1-2-表设计的优化"><a href="#1-2-表设计的优化" class="headerlink" title="1.2  表设计的优化"></a>1.2  表设计的优化</h2><h3 id="1-2-1、-字段类型优先级"><a href="#1-2-1、-字段类型优先级" class="headerlink" title="1.2.1、     字段类型优先级"></a>1.2.1、     字段类型优先级</h3><p>Bit&gt;int，int&gt;date,time&gt;char,varchar&gt;text，原因：整型，time运算快，节省空间。</p>
<p>所以我们在表设计时，如果是bool类型的数据值就不应该用int类型字段。</p>
<h3 id="1-2-2、-聚集索引字段类型的选择"><a href="#1-2-2、-聚集索引字段类型的选择" class="headerlink" title="1.2.2、     聚集索引字段类型的选择"></a>1.2.2、     聚集索引字段类型的选择</h3><p><img src="clip_image001.png" alt="img"></p>
<p>主键的索引结构中，即存储了主键值，又存储了行数据，这种结构称为“聚集索引”</p>
<p>在插入数据时，数据节点会分裂，这个问题比较严重，节点下存储了“行数据”，分裂的时候，还要移动行数据。如果主键是无规律的，则会加速它的数据节点分裂，且效率极低。</p>
<p>高性能索引策略：</p>
<p>主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。索引长度直接影响索引文件大小，影响增删改的速度，并间接影响查询速度（占用内存多）。因为主键索引在物理存放时是有序的，如果主键的值是无序的，那么主键每次插入时，索引文件都重新进行排序，会产生额外的数据消耗，另外主键的叶子上存放的数据，还会导致叶子数据行的移动和分裂，又会产生一些消耗，所以主键尽量用整型，且自增的类型。</p>
<h3 id="1-2-3、-纵向拆分"><a href="#1-2-3、-纵向拆分" class="headerlink" title="1.2.3、     纵向拆分"></a>1.2.3、     纵向拆分</h3><p>纵向拆分方法：把不需要用于查询的大字段，放到另外一个新建的附属表中，如feelingStructured表和Auto表。这样就将Evaluation表的数据内容减少到最少，存储块中可以多存储许多数据行，减少程序读取存储块的个数。</p>
<h3 id="1-2-4、-横向拆分"><a href="#1-2-4、-横向拆分" class="headerlink" title="1.2.4、     横向拆分"></a>1.2.4、     横向拆分</h3><p>横向拆分方法：表分区，表分区的条件，一张数据表的行数至少要达3000W行以上的数据，就可以考虑做表分区了。但这不是绝对，如果表的数据行内容特别多，查询特别慢时，也可以尽早做表分区。</p>
<p>注意问题：普通表在查询时，会比分区表要快一些，因为基于分区表的查询会遍历所有的分区表，而普通表只查询了普通表一个表。</p>
<p>解决办法，在查询条件中加入分区条件，这样查询就会落入指定的分区中，不用遍历所有的分区，但问题是，是不是所有的查询都能加入分区条件呢。只要进行了表分区，那么SQL的前提条件就是所有SQL都要加上分区条件，除非个别的汇总，统计类的SQL。</p>
<h3 id="1-2-5、-数据库分库"><a href="#1-2-5、-数据库分库" class="headerlink" title="1.2.5、     数据库分库"></a>1.2.5、     数据库分库</h3><p>数据库分库：当一个台数据库表服务器访问压力过大，数据量过大时，就需要考虑进行数据库分库，数据库分库条件和表分区的逻辑是比较像的。根据业务条件，如地区，时间，进行拆分。</p>
<h3 id="1-2-6、-读索引为什么比读表快"><a href="#1-2-6、-读索引为什么比读表快" class="headerlink" title="1.2.6、     读索引为什么比读表快"></a>1.2.6、     读索引为什么比读表快</h3><p>这里面引发出一个触类旁通的问题，为什么索引查询会比直接查数据要快？因为索引做为一个独立的数据存储区，也是跟数据表存储块一样，以8KB为一个存储块，一个IO读取一次存储块，而索引中只有简单的几个索引列，而不是整个数据行的数据，所以它一个IO读取的数据会非常多，这样它的IO就会非常少，加快了查询速度。</p>
<h3 id="1-2-7、-数据压缩的利与弊"><a href="#1-2-7、-数据压缩的利与弊" class="headerlink" title="1.2.7、     数据压缩的利与弊"></a>1.2.7、     数据压缩的利与弊</h3><p>数据压缩和索引压缩会使存储空间和逻辑读减少，但是会使表更新的开销加大，查询耗费的CPU也更多，所以压缩表一般适合在更新比较少，且CPU消耗不大，IO消耗很大系统中适用。像企业管理软件就比较适用于数据压缩和BI系统。如果当前系统的IO并不高，但CPU非常繁忙，则不应该采用表和索引压缩，传统数据库的压缩率并不是太高，真正压缩率比较高的应该是BI的数据。</p>
<h1 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2    索引优化"></a>2    索引优化</h1><h2 id="2-1-索引列的设计与优化"><a href="#2-1-索引列的设计与优化" class="headerlink" title="2.1  索引列的设计与优化"></a>2.1  索引列的设计与优化</h2><p>索引列数据的重复度称为可选择性，如性别列的取值范围为”男，女”，这个索引列可选择性就比较低，你在里面能找出太多相同的数据列出来，如选择列数据内容为唯一的，则可选择性非常高。我们选择索引列时，要尽量选择高选择性的列。</p>
<p>案例分析：现在有一个商家黑盒处罚功能，假如商家发布违规的商品和促销信息，则会被系统管理员设置为5天或10天的墨盒状态，墨盒状态期间无法发布商品和促销信息，现在设计有商家黑盒表，有3字段，BusinessID（商家ID）， 生效开始时间（StartTime）、生效结束时间（EndTime），这生效开始时间和生效结束时间2个列谁的选择性高呢？</p>
<p>示例业务数据：</p>
<table>
<thead>
<tr>
<th>BusinessID</th>
<th>StartTime</th>
<th>EndTime</th>
</tr>
</thead>
<tbody><tr>
<td>11111</td>
<td>2014-3-1</td>
<td>2014-3-5</td>
</tr>
<tr>
<td>223333</td>
<td>2015-4-8</td>
<td>2015-4-13-</td>
</tr>
<tr>
<td>23423424</td>
<td>2016-1-13</td>
<td>2016-1-18</td>
</tr>
</tbody></table>
<p>现在找出今天还属于黑盒的商家名单列表</p>
<p>Where startTime&lt;=’2016-1-14’ and EndTime&gt;=’2016-1-14’</p>
<p>大家可以看到，符合startTime&lt;=’2016-1-14’的有3条记录，而符合EndTime&gt;=’2016-1-14’的只有1条记录，所以EndTime的可选择性比StartTime高，这就会决定，我们到底是采用哪一列做索引列，如果2个列都做索引列，哪个索引列会排在前面（多列索引的设计见下面）。</p>
<h2 id="2-2-表扫描查询如何修改为索引列扫描"><a href="#2-2-表扫描查询如何修改为索引列扫描" class="headerlink" title="2.2  表扫描查询如何修改为索引列扫描"></a>2.2  表扫描查询如何修改为索引列扫描</h2><p>如：我们项目中以前用来判断用户是否填写Feeling时，用where len(feeling)&gt;0，len(best)&gt;0，</p>
<p>Len(wrost)&gt;0，</p>
<p>在where条件中用函数会导致表扫描，所以应该设计成标识字段，如IsEditFeeling(bit)，IsWroteBest(bit)，IsWroteWrost(bit)，SQL就可以优化成where IsEditFeeling=1，IsWrostBest=1，IsWroteWrost=1。这样就是索引扫描。</p>
<h2 id="2-3-单列索引的设计与优化"><a href="#2-3-单列索引的设计与优化" class="headerlink" title="2.3  单列索引的设计与优化"></a>2.3  单列索引的设计与优化</h2><p>单列索引设计比较简单，一般就是根据业务条件来定义就行，如根据车系ID或车型ID。但要注意索引列的可选择性。</p>
<h2 id="2-4-多列索引的设计与优化"><a href="#2-4-多列索引的设计与优化" class="headerlink" title="2.4  多列索引的设计与优化"></a>2.4  多列索引的设计与优化</h2><h3 id="2-4-1、-多列索引的存储规则"><a href="#2-4-1、-多列索引的存储规则" class="headerlink" title="2.4.1、     多列索引的存储规则"></a>2.4.1、     多列索引的存储规则</h3><p>假设某个表有一个联合索引(a,b,c)，我们来看下在这个索引中是如何存储这些字段数据的。</p>
<p><img src="clip_image003.jpg" alt="img"></p>
<p><img src="clip_image005.jpg" alt="img"></p>
<h3 id="2-4-2、-多列索引左前缀规则"><a href="#2-4-2、-多列索引左前缀规则" class="headerlink" title="2.4.2、     多列索引左前缀规则"></a>2.4.2、     多列索引左前缀规则</h3><p>多列索引必须用到第1个，否则不生效。</p>
<p><img src="clip_image006.png" alt="img"></p>
<h3 id="2-4-3、-多列索引列的选择优化"><a href="#2-4-3、-多列索引列的选择优化" class="headerlink" title="2.4.3、     多列索引列的选择优化"></a>2.4.3、     多列索引列的选择优化</h3><p>根据以上的多列索引列的存储规则和左前缀规则，在建多列索引时，应该将可选择项高的列放在最左边，后面依次类推，如上面的黑盒案例分析中，应该将endTime列放在最左边，然后才是starttime列。</p>
<p>在选择性相同的情况下，应该把等值（如：=）的放在左边，不等值（如：&gt;，&lt;）放在后面。</p>
<p>Select * from t where object_id&gt;=20 andobject_id&lt;2000 and object_type=’TABLE’;</p>
<p>这个查询对应的索引，应该建成</p>
<p>Create index idx_id_type on t(object_type,object_id);</p>
<h2 id="2-5-书签查找优化"><a href="#2-5-书签查找优化" class="headerlink" title="2.5  书签查找优化"></a>2.5  书签查找优化</h2><p><strong>2.5.</strong>      </p>
<h3 id="2-5-1、-数据表物理存储和索引的物理索引"><a href="#2-5-1、-数据表物理存储和索引的物理索引" class="headerlink" title="2.5.1、     数据表物理存储和索引的物理索引"></a>2.5.1、     数据表物理存储和索引的物理索引</h3><p><img src="clip_image008.jpg" alt="img"></p>
<p><strong>数据存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>数据存储块**</strong>2**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>索引存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>非聚集索引1(include(区))</th>
<th>非聚集索引2</th>
<th>非聚集索引N</th>
</tr>
</thead>
<tbody><tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
<tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
<tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
</tbody></table>
<p>因为索引里面只存储了固定了几列，如果查询时需要读取索引列之外的数据，就需要到数据存储块，根据聚集索引去重新查找我们想要的数据，这就叫书签查找。</p>
<h3 id="2-5-2、-书签查找的缺点"><a href="#2-5-2、-书签查找的缺点" class="headerlink" title="2.5.2、     书签查找的缺点"></a>2.5.2、     书签查找的缺点</h3><p><img src="clip_image010.jpg" alt="img"></p>
<p><img src="clip_image012.jpg" alt="img"></p>
<p>找出书签查找中查找的列</p>
<p><img src="clip_image014.jpg" alt="img"></p>
<h3 id="2-5-3、-书签查找优化"><a href="#2-5-3、-书签查找优化" class="headerlink" title="2.5.3、     书签查找优化"></a>2.5.3、     书签查找优化</h3><p><img src="clip_image016.jpg" alt="img"></p>
<p><img src="clip_image018.jpg" alt="img"></p>
<h2 id="2-6-索引与排序的优化"><a href="#2-6-索引与排序的优化" class="headerlink" title="2.6  索引与排序的优化"></a>2.6  索引与排序的优化</h2><p>索引在物理存储上是有序的，所以如果我们的SQL的排序是基于索引列进行的，那么不需要再重新进行排序，反之，系统会在temp库中建立表变量或临时表，然后在这个表变量或临时表中重新进行排序。如果想为多表联查时，基于多个表做排序字段建立索引，如Order by A.Id,B.Created，则可以基于2个表建立一个物化视图，然后在这个物化视图上为这2列建立索引。</p>
<p>Create index idx_t on t(col1 desc,col2 asc)</p>
<p>Select * from t order by col1 desc,col2 asc</p>
<p>0：sorts(memory)</p>
<p>0：sorts(disk)</p>
<p><img src="clip_image020.jpg" alt="img"></p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 2182 毫秒，占用时间= 231 毫秒。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<p><img src="clip_image022.jpg" alt="img"></p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 0 毫秒，占用时间= 2 毫秒。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<h2 id="2-7-关于索引的坏处"><a href="#2-7-关于索引的坏处" class="headerlink" title="2.7  关于索引的坏处"></a>2.7  关于索引的坏处</h2><p>在有几个索引和情况下和只有主键索引的情况下，插入数据的速度相差10倍，而且数据表里数据记录越大，插入速度越明显。</p>
<p>在无索引的情况下，表的记录越大，插入的速度只会受到很小的影响，基本不会越慢。</p>
<p>在无索引的情况下，分区表的插入要比普通表更慢，因为插入的数据需要做判断，有这方面的开销。</p>
<p>解决办法：读写分离，在主库（或叫写库）上只有主键索引，而没有别的索引。只读库上有许多用于查询的索引，然后写库的数据定时同步到只读库上，这样的话，插入时不会因为索引的原因导致插入变慢，也不会因为没有索引导致查询变慢。</p>
<h2 id="2-8-索引建立时的开销及注意事项"><a href="#2-8-索引建立时的开销及注意事项" class="headerlink" title="2.8  索引建立时的开销及注意事项"></a>2.8  索引建立时的开销及注意事项</h2><p>建索引过程会产生全表锁和建索引过程中会产生全表排序.</p>
<p>后果：普通的对表建索引将会导致针对该表的更新操作无法进行，需要等待索引建完，更新操作将会被建索引的动作阻塞。</p>
<p>解决办法：</p>
<p>CREATE NONCLUSTERED INDEX [IX_Auto_Serial] ON [dbo].[Auto] </p>
<p>(</p>
<p>  [Serial] ASC,</p>
<p>  [RowStatus] ASC</p>
<p>)</p>
<p> WITH ( ONLINE = ON) </p>
<p>在创建索引时，加上online参数，这种建索引的方式不会阻止针对该表的更新操作，与建普通索引相反的是，online建索引的动作是反过来被更新操作阻塞。</p>
<h1 id="3-多表联查优化"><a href="#3-多表联查优化" class="headerlink" title="3    多表联查优化"></a>3    多表联查优化</h1><h2 id="3-1-、字段冗余，不要联查"><a href="#3-1-、字段冗余，不要联查" class="headerlink" title="3.1  、字段冗余，不要联查"></a>3.1  、字段冗余，不要联查</h2><p>业务案例分析：在口碑表里冗余新建一个LastAppendingDrivenKilometers字段，这样就不用关联追加表进行查询了。再冗余新建一个AutoBoughtCity字段，就不用关联Auto表进行查询了。</p>
<h2 id="3-2-、多表联查的实现原理及表关联字段的设计原则"><a href="#3-2-、多表联查的实现原理及表关联字段的设计原则" class="headerlink" title="3.2  、多表联查的实现原理及表关联字段的设计原则"></a>3.2  、多表联查的实现原理及表关联字段的设计原则</h2><p>三大表连接的概要说明：1、Nested Loops Join。2、Hash Join。3、Merge Sort Join</p>
<p>Nested Loops Join驱动结果集的条数决定被驱动表的访问次数</p>
<p>Hash Join两表各自只会访问1次或0次。</p>
<p>Merge Sort Join与Hash Join的相同</p>
<p>表驱动顺序与性能（Nested LoopsJoin性能与驱动顺序有关）</p>
<p>Hash Join性能与驱动顺序有关（和NL相似）</p>
<p>Merge Sort Join性能与表驱动顺序无关</p>
<p><img src="clip_image023.png" alt="img"></p>
<p><img src="clip_image024.png" alt="img"></p>
<p>Nested Loops Join优化要点</p>
<p>1：驱动表的限制条件要有索引。2、被驱动表限制条件要建立索引。3：确保小结果集先驱动，大的被驱动。</p>
<p>Hash Join忧化要点：1：请确保用在全扫描的OLAP场景。2：明确该SQL是否限制Hash Join。3、两表无任何索引倾向HashJoin。第1斧：两表限制条件有索引（看返回量）。第2斧：要小结果集先驱动，大的被驱动。第3斧：尽量保证PGA能容纳Hash运算。</p>
<p>Merge Sort Join优化第1式（两表限制条件有索引）</p>
<p>Merge Sort Join 优化第2式（连接条件索引消除排序，即消除2边分别排序，再合并的这种情况）</p>
<p>因为被驱动表的查询是依赖与ON 条件中写的字段列，如： A join B on A.CID=B.C ID，</p>
<p>那么应该B表的CID设置为索引列，最好设置为聚集索引列，这样关联SQL在运行时，从B表中查找数据时，可以命中索引，否则在B表中查找数据时，会引发表扫描和Hash匹配。</p>
<p>代码示例：</p>
<p>优化前的效果</p>
<p>(1 row(s) affected)</p>
<p>表 ‘Worktable’。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘EvaluationPurposeTerms’。扫描计数 1，逻辑读取 1383 次，物理读取 3 次，预读 2269 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘Evaluation’。扫描计数 1，逻辑读取 110 次，物理读取 2 次，预读 80 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>(1 row(s) affected)</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间 = 140 毫秒，占用时间 = 155 毫秒。</p>
<p><img src="clip_image026.jpg" alt="img"></p>
<p>优化后的SQL:</p>
<p>(1 row(s) affected)</p>
<p>表 ‘EvaluationPurposeTerms’。扫描计数 0，逻辑读取 1638 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘Evaluation’。扫描计数 1，逻辑读取 20 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间 = 0 毫秒，占用时间 = 4 毫秒。</p>
<p><img src="clip_image028.jpg" alt="img"></p>
<h2 id="3-3-、关联查询的优化（使用表扫描）"><a href="#3-3-、关联查询的优化（使用表扫描）" class="headerlink" title="3.3  、关联查询的优化（使用表扫描）"></a>3.3  、关联查询的优化（使用表扫描）</h2><p>QualityProblem是一个数据表，QualityProblemDictionary是一个字典表，字典表的数据基本上是固定不变的，大概80行的样子。而在与QualityProblem表关联时，QualityProblem表中符合条件数据的，每一行都会读取一次QualityProblemDictionary字典表。SQL和运行效果如下，现在打算将QualityProblemDictionary字典表一次全读取到内存中，这样就不用每条符合条件的QualityProblem表中数据都去访问QualityProblemDictionary字典表了，修改方法就是在表的Hint中指出不要用索引扫描，要采用表扫描。代码：with(index(0))</p>
<p>SELECT [QualityId] ,[ItemId] AS [ID] ,d.Name ,d.FullName ,d.FullPath ,d.Level ,d.ParentId FROM [QualityProblem] as p with(nolock)</p>
<p>join [QualityProblemDictionary] as d with(nolock) on d.Id = p.ItemId where p.QualityId = 592805 </p>
<p>优化前效果：</p>
<p>(7 row(s) affected)</p>
<p>表’QualityProblemDictionary’。扫描计数7，逻辑读取14 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblem’。扫描计数1，逻辑读取3 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 15 毫秒，占用时间= 23 毫秒。</p>
<p>as d with(index(0),nolock) on d.Id = p.ItemId</p>
<p>优化后效果：</p>
<p>(7 row(s) affected)</p>
<p>表’Worktable’。扫描计数0，逻辑读取0 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblemDictionary’。扫描计数1，逻辑读取19 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblem’。扫描计数1，逻辑读取3 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 0 毫秒，占用时间= 2 毫秒。</p>
<h1 id="4-查询计划的缓存与CPU高优化"><a href="#4-查询计划的缓存与CPU高优化" class="headerlink" title="4    查询计划的缓存与CPU高优化"></a>4    查询计划的缓存与CPU高优化</h1><p><strong>1</strong>   </p>
<p><strong>2</strong>   </p>
<p><strong>3</strong>   </p>
<p><strong>4</strong>   </p>
<h2 id="4-1-、概述"><a href="#4-1-、概述" class="headerlink" title="4.1  、概述"></a>4.1  、概述</h2><p>我们SQL执行分为2部分，1是SQL查询计划编译部分，2是SQL运行部分。SQL分析器里显示的CPU时间也是包括编译时间和运行时间。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 2668 毫秒，占用时间= 786 毫秒。</p>
<p>因为生成SQL的查询计划是非常耗时和耗CPU的，SQL Server在生成查询计划之后，会将已经生成的查询计划保存到计划缓存中，下次再执行该SQL时不用再重新生成一个全新的计划。</p>
<h2 id="4-2-、如何使查询计划被缓存"><a href="#4-2-、如何使查询计划被缓存" class="headerlink" title="4.2  、如何使查询计划被缓存"></a>4.2  、如何使查询计划被缓存</h2><h3 id="4-2-1、-sp-executesql存储过程"><a href="#4-2-1、-sp-executesql存储过程" class="headerlink" title="4.2.1、     sp_executesql存储过程"></a>4.2.1、     sp_executesql存储过程</h3><p>普通的即席SQL的查询计划是没有被缓存的，通过下面的示例可以看出来。</p>
<p><img src="clip_image029.png" alt="img"></p>
<p><img src="clip_image030.png" alt="img"></p>
<p>通过把SQL改写为用sp_executesql存储过程，即可实现查询计划被缓存。ado.net底层就是把我们写的SQL全部生成sp_executesql sql这种格式的sql，但ado.net无法自动区分我们sql中哪些是参数，哪些不是参数，所以光靠ado.net帮我们自动实现sp_executesql还无法实现查询计划的缓存，还需要我们手动把查询条件参数化写完整。最终实现一个标准的语法</p>
<p>Sp_executesql @sqltext,@param1,,,,,,@paramN</p>
<p><img src="clip_image032.jpg" alt="img"></p>
<p><img src="clip_image033.png" alt="img"></p>
<p><img src="clip_image035.jpg" alt="img"></p>
<p>​      </p>
<h3 id="4-2-2、-存储过程和函数"><a href="#4-2-2、-存储过程和函数" class="headerlink" title="4.2.2、     存储过程和函数"></a>4.2.2、     存储过程和函数</h3><p>存储过程和函数的查询计划也会被缓存。</p>
<h2 id="4-3-、如何解决查询计划不被缓存"><a href="#4-3-、如何解决查询计划不被缓存" class="headerlink" title="4.3  、如何解决查询计划不被缓存"></a>4.3  、如何解决查询计划不被缓存</h2><p>只要采用sp_executesql，存储过程，函数这3种方式写的sql查询计划就会被缓存，但也有原因会导致他们不会被缓存，原因如下：</p>
<p><img src="clip_image037.jpg" alt="img"></p>
<h3 id="4-3-1、-查询计划不被缓存案例示警"><a href="#4-3-1、-查询计划不被缓存案例示警" class="headerlink" title="4.3.1、     查询计划不被缓存案例示警"></a>4.3.1、     查询计划不被缓存案例示警</h3><p>上次线上数据库CPU总是高，从DMV中查到编译数过高，原因是开发人员为线上跟踪代码运行结果和查错方便，在公共数据访问层中，自动为每一条SQL中都加了一条注释，该注释内容为当前系统的Url，因为一个公共方法会被不同模块调用，当前模块的Url自然也是不停的在变，导致SQL的查询计划无法重用。</p>
<h2 id="4-4-、缓存的查询计划什么时候被重新生成"><a href="#4-4-、缓存的查询计划什么时候被重新生成" class="headerlink" title="4.4  、缓存的查询计划什么时候被重新生成"></a>4.4  、缓存的查询计划什么时候被重新生成</h2><p>1、当表数据增长率达到当前数据量的30%时，查询计划会被重编译。</p>
<p>2、当新建和修改索引时。</p>
<p>3、当新建和删除字段时。</p>
<h2 id="4-5-、In条件参数化"><a href="#4-5-、In条件参数化" class="headerlink" title="4.5  、In条件参数化"></a>4.5  、In条件参数化</h2><p>Declare @User1 int;Declare @User2 int;Declare @User3 int;Declare @User4 int;declare @User5 int;</p>
<p>Where userId in(@User1,@User2,@User3,@User4,@User5)</p>
<h1 id="5-并发和阻塞问题"><a href="#5-并发和阻塞问题" class="headerlink" title="5    并发和阻塞问题"></a>5    并发和阻塞问题</h1><p>1、减少事务长度。</p>
<p>2、SQL语句加Nolock。</p>
<p>3、读写分离</p>
<h1 id="6-日志库优化"><a href="#6-日志库优化" class="headerlink" title="6    日志库优化"></a>6    日志库优化</h1><p>当有insert和update,delete操作时，会在日志库中记录日志，随着时间的积累，日志库记录越来越多，每插入一条日志都非常耗时，直接影响我们系统的数据操作。</p>
<p>解决办法：设定每天晚上自动备份，在数据库备份之后，数据库会自动收缩日志库，删除一些日志数据，这样日志库的数据量就下来了。因为数据库觉得你已经备份过了，万一出什么问题，可以用备份文件来恢复，也不需要依靠日志库来进行还原了，没必要再保存那么多日志了。</p>
<h1 id="7-SQLServer服务器系统参数配置与性能优化"><a href="#7-SQLServer服务器系统参数配置与性能优化" class="headerlink" title="7    SQLServer服务器系统参数配置与性能优化"></a>7    SQLServer服务器系统参数配置与性能优化</h1><h2 id="7-1-、CPU最大并行度"><a href="#7-1-、CPU最大并行度" class="headerlink" title="7.1  、CPU最大并行度"></a>7.1  、CPU最大并行度</h2><p>详细描述文档：<a target="_blank" rel="noopener" href="http://jimshu.blog.51cto.com/3171847/1266978">http://jimshu.blog.51cto.com/3171847/1266978</a></p>
<p><img src="clip_image039.jpg" alt="img"></p>
<h2 id="7-2-、并行性开销阀值"><a href="#7-2-、并行性开销阀值" class="headerlink" title="7.2  、并行性开销阀值"></a>7.2  、并行性开销阀值</h2><p><img src="clip_image041.jpg" alt="img"></p>
<h2 id="7-3-、优化即席工作负载"><a href="#7-3-、优化即席工作负载" class="headerlink" title="7.3  、优化即席工作负载"></a>7.3  、优化即席工作负载</h2><h2 id="7-4-、数据库文件布局"><a href="#7-4-、数据库文件布局" class="headerlink" title="7.4  、数据库文件布局"></a>7.4  、数据库文件布局</h2><p>将数据库文件分别存放在不同的服务器上，以加快并行处理速度。</p>
<h1 id="8-DB服务器监控"><a href="#8-DB服务器监控" class="headerlink" title="8    DB服务器监控"></a>8    DB服务器监控</h1><p>参考附件</p>
<p>数据性能调校–查出最耗资源的各种SQL.docx</p>
<h1 id="9-SQL语句性能优化"><a href="#9-SQL语句性能优化" class="headerlink" title="9    SQL语句性能优化"></a>9    SQL语句性能优化</h1><h2 id="9-1-、SQL语句分析方法"><a href="#9-1-、SQL语句分析方法" class="headerlink" title="9.1  、SQL语句分析方法"></a>9.1  、SQL语句分析方法</h2><p>SQL分析技巧，SQL可以分为3段：</p>
<p>1、 Select部分，重点关注Select部分有没有标题子查询，有没有自定义函数</p>
<p>2、 From后面，重点关注有没有内联视图，有没有视图，有没有进行视图合并</p>
<p>3、 Where条件部分，看有没有In/Not In，Exists/Not in子查询，有没有外连接，有没有</p>
<p>在列上面有函数导致不能走索引，比如：where len(feeling)&gt;0</p>
<p>内联视图要手工运行返回多少行，子查询也要查看返回多少行。</p>
<h2 id="9-2-、子查询优化"><a href="#9-2-、子查询优化" class="headerlink" title="9.2  、子查询优化"></a>9.2  、子查询优化</h2><p>子查询的特点：主查询返回一行，子查询就会被执行一次。In语句外面是驱动表，in语句里面是被驱动表。</p>
<p>优化目的：</p>
<p>1、 子查询不用执行很多次</p>
<p>2、 优化器可以根据统计信息来选择不同的连接方法和不同的连接顺序</p>
<p>子查询中的连接条件，过滤条件分别变成了父查询的连接条件，过滤条件，优化器可以对这些条件进行下推，以提高执行效率。</p>
<h3 id="9-2-1、-非关联子查询"><a href="#9-2-1、-非关联子查询" class="headerlink" title="9.2.1、     非关联子查询"></a>9.2.1、     非关联子查询</h3><p>非关联子查询的执行，不依赖于外层父查询的任何属性值。这样子查询具有独立性，可独自求解，形成一个子查询计划先于外层的查询求解，如：</p>
<p><img src="clip_image042.png" alt="img"></p>
<p>相关和非相关子询的判断条件就是看子查询是否出现外层父查询中的数据列。</p>
<h3 id="9-2-2、-关联子查询"><a href="#9-2-2、-关联子查询" class="headerlink" title="9.2.2、     关联子查询"></a>9.2.2、     关联子查询</h3><p>相关子查询，子查询的执行依赖于外层父查询的一些属性值。子查询因依赖于父查询的参数，当父查询的参数改变时，子查询需要根据新参数值重新执行（查询优化器对相关子查询进行优化有一定意义），如：</p>
<p><img src="clip_image043.png" alt="img"></p>
<h3 id="9-2-3、-子查询优化方法一（子查询合并）"><a href="#9-2-3、-子查询优化方法一（子查询合并）" class="headerlink" title="9.2.3、     子查询优化方法一（子查询合并）"></a>9.2.3、     子查询优化方法一（子查询合并）</h3><p>子查询合并（subquery coalescing）</p>
<p>在某些条件下（语义等价：两个查询块产生同样的结果集），多个子查询能够合并成一个子查询（合并后还是子查询，以后可以通过其他技术消除掉子查询）。这样可以把多次表扫描，多次连接减少为单次表扫描和单次连接，如：</p>
<p><img src="clip_image045.jpg" alt="img"></p>
<p>可优化为：</p>
<p><img src="clip_image047.jpg" alt="img"></p>
<h3 id="9-2-4、-非关联子查询优化–子查询展开"><a href="#9-2-4、-非关联子查询优化–子查询展开" class="headerlink" title="9.2.4、     非关联子查询优化–子查询展开"></a>9.2.4、     非关联子查询优化–子查询展开</h3><p>子查询展开（subquery unnesting）。</p>
<p>又称子查询反嵌套，又称为子查询上拉。</p>
<p>把一些子查询置于外层的父查询中，作为连接关系与外层父查询并列，其实质是把某些子查询重写为等价的多表连接操作（展开后，子查询不存在了，外部查询变成了多表连接）。</p>
<p>带来的好处是，有关的访问路径，连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能的减少。</p>
<p>WHERE evl.[AutoSeries] =@id and evl.EvaluationID in (select EvaluationID from EvaluationPurposeTerms ept with(nolock) where ept.PurposeID=1)</p>
<p>修改为</p>
<p>INNER JOIN EvaluationPurposeTerms ept ON evl.EvaluationID = ept.EvaluationID</p>
<p>WHERE evl.[AutoSeries] =@id and ept.PurposeID=1</p>
<p>注意：其实子查询和联合查询中的嵌套循环查询的底层思路是一样的，都是驱动表查询被驱动表，嵌套循环的伪代码如下： </p>
<p><img src="clip_image023.png" alt="img"></p>
<p>那我们为什么还要修改子查询为关联查询呢？因为带来的好处是，有关的访问路径，连接方法和连接顺序可能被有效使用，使得查询语句的层次尽可能的减少。在子查询中，In语句外固定是驱动表，In语句内固定是被驱动表，如果驱动表返回1W条记录，那被驱动表则会被查询1W次。而关联查询时，驱动表和被驱动表的关系是根据谁返回数据行的大小来动态决定的，如A Join B，B返回10行，A返回1W行，则SQL底层执行时会将B作为驱动表，而A作为被驱动表，这样B执行一次查询，A执行10次查询，反过来如果A in(B)，则A执行一次查询，B执行1W次查询。</p>
<p>代码示例2：</p>
<p>and evl.[AutoModel] in (601,1473,1474,1993,1994,1995,2743,2750,2751,2752,3681,3682,3683,3684,5405,5819,5910,5911,10665,10666,10667,13444,13481,13482,13483,13484,13485,15377,15379,17807,17808,17809,17810,17811,17812)</p>
<p>修改方法：SQL中关联Product_Spec表，</p>
<p>INNER JOIN dbo.Product_Spec prod_Spec ON prod_Spec.SpecId=evl.AutoModel</p>
<p>WHERE prod_Spec.SyearId=452 AND SpecState=(销售状态)</p>
<h3 id="9-2-5、-关联子查询优化–子查询展开"><a href="#9-2-5、-关联子查询优化–子查询展开" class="headerlink" title="9.2.5、     关联子查询优化–子查询展开"></a>9.2.5、     关联子查询优化–子查询展开</h3><p>非关联子查询的每次查询都依赖了驱动表的行数据内容，所以想修改为子查询展开方式不太好做，但我们可以从业务上分析，将相关的数据修改为不相关的数据集合，然后再跟不相关的数据集合进行关联，但跟不相关数据集合关联时，要带上条件。</p>
<p>代码示例：</p>
<p>and ((evl.[DrivenKiloms] &gt;5000 and evl.[DrivenKiloms] &lt;=20000) or evl.EvaluationID in (select EvaluationID from EvaluationAppending with(nolock) where DrivenKilometers&gt;5000 and DrivenKilometers&lt;20000 and RowStatus=0 and EvaluationAppendingID in (select MAX(EvaluationAppendingID) as EvaluationAppendingID from EvaluationAppending where RowStatus=0 group by EvaluationID)))) as</p>
<p>上面的逻辑含义是口碑的驱动公里数&gt;5000 And &lt;=20000，或者最后一条追加口碑的驱动公里数&gt;5000 And &lt;=20000，我们可以一次性把所有口碑的最后一条追加口碑并且是符合驱动公里数&gt;5000 And &lt;20000的条件，保存到临时表或衍生数据表和CTE中，然后用这个临时表或CTE与口碑表进行关联查询，修改后的代码如下：</p>
<p>;WITH AppendEvalIDCTE AS( </p>
<p>  SELECT EvaluationID</p>
<p>​    FROM  ( SELECT  ROW_NUMBER() OVER ( PARTITION BY EvaluationID ORDER BY EvaluationAppendingID DESC ) AS RowNum ,</p>
<p>​              EvaluationID ,DrivenKilometers</p>
<p>​         FROM   EvaluationAppending with(nolock)</p>
<p>​         WHERE   RowStatus = 0</p>
<p>​        ) T</p>
<p>​    WHERE  T.RowNum = 1 AND DrivenKilometers &gt; 5000 AND DrivenKilometers &lt;= 20000 </p>
<p>)</p>
<p>关联代码：</p>
<p>INNER JOIN AppendEvalIDCTE evlAppend ON evl.EvaluationID = evlAppend.EvaluationID</p>
<p>Where  evl.[DrivenKiloms] &gt; 5000 AND evl.[DrivenKiloms] &lt;= 20000</p>
<h3 id="9-2-6、-关联子查询优化–谓词推入"><a href="#9-2-6、-关联子查询优化–谓词推入" class="headerlink" title="9.2.6、     关联子查询优化–谓词推入"></a>9.2.6、     关联子查询优化–谓词推入</h3><p>​     谓词推入：当SQL语句中包含有不能合并的视图，并且视图有谓词过滤（也就是where过滤条件），CBO会将where过滤条件推入视图中，这个就叫做谓词推入。谓词推入主要目的就是让SQL Server尽可能早的过滤掉无用的数据，从而提升查询性能。</p>
<p>当SQL语句中，OR条件上面有一个为子查询，并且子查询上的表与源表不同，这个时候就可以用union代替OR或者你发现执行计划中的filter有or并且or后面跟上子查询(Exists)的时候就要注意，比如：</p>
<p><img src="clip_image049.jpg" alt="img"></p>
<p>修改为：</p>
<p><img src="clip_image051.jpg" alt="img"></p>
<p>代码示例：</p>
<p>;WITH AppendEvalIDCTE AS( </p>
<p>  SELECT EvaluationID</p>
<p>​    FROM  ( SELECT  ROW_NUMBER() OVER ( PARTITION BY EvaluationID ORDER BY EvaluationAppendingID DESC ) AS RowNum ,</p>
<p>​              EvaluationID ,DrivenKilometers</p>
<p>​         FROM   EvaluationAppending with(nolock)</p>
<p>​         WHERE   RowStatus = 0</p>
<p>​        ) T</p>
<p>​    WHERE  T.RowNum = 1 AND DrivenKilometers &gt; 5000 AND DrivenKilometers &lt;= 20000 </p>
<p>)</p>
<p>, AllEvalIDCTE AS</p>
<p>( </p>
<p>  SELECT HelpfulCount,LastAppend,Grade,AppendCount,EvaluationID FROM</p>
<p>  ( </p>
<p>​    SELECT evl.HelpfulCount,evl.LastAppend, evl.Grade ,evl.AppendCount,evl.EvaluationID FROM Evaluation evl </p>
<p>​    INNER JOIN [Auto] at WITH ( NOLOCK ) ON at.AutoID = evl.AutoID</p>
<p>​     WHERE evl.[AutoSeries] =@id</p>
<p>​        AND evl.[DrivenKiloms] &gt; 5000 AND evl.[DrivenKiloms] &lt;= 20000</p>
<p>​    UNION</p>
<p>​     SELECT evl.HelpfulCount,evl.LastAppend, evl.Grade ,evl.AppendCount,evl.EvaluationID FROM Evaluation evl </p>
<p>​     INNER JOIN [Auto] at WITH ( NOLOCK ) ON at.AutoID = evl.AutoID </p>
<p>​    INNER JOIN AppendEvalIDCTE evlAppend ON evl.EvaluationID = evlAppend.EvaluationID</p>
<p>​     WHERE evl.[AutoSeries] =@id  </p>
<p>​        –不能再有了AND evl.[DrivenKiloms] &gt; 5000 AND evl.[DrivenKiloms] &lt;= 20000 </p>
<p>  ) T</p>
<p>)</p>
<h3 id="9-2-7、-子查询优化—-Update语句"><a href="#9-2-7、-子查询优化—-Update语句" class="headerlink" title="9.2.7、     子查询优化—-Update语句"></a>9.2.7、     子查询优化—-Update语句</h3><p>update table_1 set score = score + 5 where uid in (<a target="_blank" rel="noopener" href="http://www.111cn.net/tags.php/select/">select</a> uid from table_2 where sid = 10);</p>
<p>其实update也可以用到left join、inner join来进行关联，可能执行效率更高，把上面的sql替换成join的方式如下：</p>
<p>update table_1 t1 inner join table_2 t2 on t1.uid = t2.uid set score = score + 5 where t2.sid = 10;</p>
<h3 id="9-2-8、-子查询优化—-字段冗余"><a href="#9-2-8、-子查询优化—-字段冗余" class="headerlink" title="9.2.8、     子查询优化—-字段冗余"></a>9.2.8、     子查询优化—-字段冗余</h3><p>在Evaluation表新建一个LastAppendingDrivenKilometers字段</p>
<p>用于冗余存放EvaluationAppending表中当前口碑的最后一条追加数据的DrivenKilometers字段数据，代码就简洁多了。</p>
<h3 id="9-2-9、-子查询优化—-物化视图（索引视图）"><a href="#9-2-9、-子查询优化—-物化视图（索引视图）" class="headerlink" title="9.2.9、     子查询优化—-物化视图（索引视图）"></a>9.2.9、     子查询优化—-物化视图（索引视图）</h3><p>物化视图概念：对于涉及对大量的行进行复杂处理的非索引视图，为引用视图的每个查询动态生成结果集的开销会很大。这类视图包括聚集大量数据或联接许多行的视图。若经常在查询中引用这类视图，可通过在视图上创建唯一聚集索引来提高性能。在视图上创建唯一聚集索引时将执行该视图，并且结果集将存储在数据库中，就像带有聚集索引的表一样。</p>
<p>对于涉及对大量的行进行复杂处理的视图，由于结果集已经保存为一张带有聚集索引的表，因此无需重新计算，索引视图有明显的速度优势。</p>
<p>案例分析：</p>
<p><img src="clip_image052.png" alt="img"></p>
<p> SELECT ps.BrandId ,SUM(tfw.SCount) SCount FROM  [Replication].dbo.dxp_SaleData_Cleaned_Count tfw WITH(NOLOCK)INNER JOIN dbo.Product_Series ps WITH ( NOLOCK ) ON ps.SeriesId = tfw.SeriesId</p>
<p>​           WHERE ( tfw.Syear = @spFromYear AND tfw.Smonth &gt;= @spFromMonth )</p>
<p>​              OR ( tfw.Syear = @spToYear AND tfw.Smonth &lt; @spToMonth)</p>
<p>​              OR ( tfw.Syear &gt; @spFromYear AND tfw.Syear &lt; @spToYear)</p>
<p>​           GROUP BY ps.BrandId) s ON s.BrandId = sbf.BrandId</p>
<p>WHERE  1 = 1 AND sbf.CarType = 1 AND sbf.CountryId IN (1,2,3,4,5,6)</p>
<p>(8 行受影响)</p>
<p>表’dxp_SaleData_Cleaned_Count’。扫描计数1，逻辑读取378 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’Product_Series’。扫描计数1，逻辑读取10 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 15 毫秒，占用时间= 15 毫秒。</p>
<p>CREATE VIEW v_dxp_SaleData_Cleaned_Count WITH SCHEMABINDING AS</p>
<p>SELECT id,SeriesId,SCount,(Syear*100+Smonth))AS YearMonth</p>
<p>FROM dbo.dxp_SaleData_Cleaned_Count</p>
<p>CREATE UNIQUE CLUSTERED INDEX v_dxp_SaleData_Cleaned_Count_Idx_ID ON v_dxp_SaleData_Cleaned_Count(id ASC);</p>
<p>CREATE NONCLUSTERED INDEX v_dxp_SaleData_Cleaned_Count_Idx_YearMonth ON v_dxp_SaleData_Cleaned_Count(YearMonth ASC)INCLUDE(SeriesId,SCount);</p>
<p>;WITH CTE AS</p>
<p>(</p>
<p>SELECT ps.BrandId , SUM(tfw.SCount) SCount FROM  [Replication].dbo.v_dxp_SaleData_Cleaned_Count tfw WITH(NOLOCK)</p>
<p>INNER JOIN koubei.dbo.Product_Series ps WITH ( NOLOCK ) ON ps.SeriesId = tfw.SeriesId </p>
<p>WHERE tfw.YearMonth&gt;=201407 AND tfw.yearmonth&lt;201511 GROUP BY ps.BrandId</p>
<p>)</p>
<p>SELECT sbf.BrandId Id,sbf.BrandName Name,sbf.PPH ,sbf.DefectiveSampleCount ,</p>
<p>​    sbf.TroublefreeSamplesCount ,CTE.SCount</p>
<p>FROM  koubei.dbo.Stat_Brand_Fault sbf WITH ( NOLOCK ) INNER JOIN CTE ON CTE.BrandId = sbf.BrandId</p>
<p>WHERE  1 = 1 AND sbf.CarType = 1 AND sbf.CountryId &gt;=1 AND sbf.CountryId&lt;=6 – (1,2,3,4,5,6)</p>
<p>表’v_dxp_SaleData_Cleaned_Count’。扫描计数1，逻辑读取34 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’Product_Series’。扫描计数1，逻辑读取10 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 0 毫秒，占用时间= 5 毫秒。</p>
<h2 id="9-3-、海量数据分页优化"><a href="#9-3-、海量数据分页优化" class="headerlink" title="9.3  、海量数据分页优化"></a>9.3  、海量数据分页优化</h2><h3 id="9-3-1、-延迟索引"><a href="#9-3-1、-延迟索引" class="headerlink" title="9.3.1、     延迟索引"></a>9.3.1、     延迟索引</h3><p>海量数据分页优化的2个重要思想就是：延迟索引和延迟关联。</p>
<p>举例：</p>
<p>select id,name from lx_com join userInfo between 5000000 and 5000010;</p>
<p>这个SQL中，它的工作原理是，他先取500W条，并且因为name字段不是主键，需要不断的回行到磁盘上去取，然后最后返回的是500W到5000010行数据，那么前500W行数据的name，又要扔掉，不返给客户端，这样就形成极大的资源浪费。</p>
<p>修改为</p>
<p>With T as (select id from lx_com between 5000000 and 5000010) </p>
<p>select id,name from UserInfo join T on UserInfo.id=T.id</p>
<p>具体项目中的应用：</p>
<p>;WITH AllCTE AS( SELECT evl.EvaluationID,ROW_NUMBER() OVER(ORDER BY evl.Grade desc,evl.AppendCount desc,evl.LastAppend desc) </p>
<p>AS RowNum FROM Evaluation evl WITH(NOLOCK)</p>
<p>WHERE  evl.[AutoSeries]=@id),evlCTE AS </p>
<p>(SELECT TOP 100 PERCENT EvaluationID,RowNum FROM AllCTE WHERE RowNum BETWEEN @pagstart AND @pagend ORDER BY RowNum ASC)</p>
<h3 id="9-3-2、-延迟关联"><a href="#9-3-2、-延迟关联" class="headerlink" title="9.3.2、     延迟关联"></a>9.3.2、     延迟关联</h3><p> SELECT evlCTE.RowNum,evl.AppendCount,evl.EvaluationID,evl.AutoID,at.Brand AS AutoBrand,evl.AutoModel,evl.AutoSeries</p>
<p>​           ,evl.AutoOwner,at.[Level] AS AutoLevel,evl.CommentCount,evl.HelpfulCount</p>
<p>​        ,evl.Created,evl.FeelingSummary ,at.BoughtDate AS AutoBoughtDate,at.BoughtProvince AS AutoBoughtProvince</p>
<p>,at.BoughtCity AS AutoBoughtCity, up.MemberId,up.NickName,up.IsAuthenticated,up.Gender,up.HeadImage,up.UserGrade,ps.SpecName</p>
<p>,ps.MinPrice,pss.SeriesName,pss.IsElectric </p>
<p>FROM evlCTE INNER JOIN Evaluation evl WITH(NOLOCK) ON evlCTE.EvaluationID = evl.EvaluationID</p>
<p>INNER JOIN [Auto] at with(nolock) ON at.AutoID = evl.AutoID INNER JOIN UserProxy up with(nolock) ON up.UserID = evl.AutoOwner</p>
<p>INNER JOIN Product_Spec ps with(nolock) ON ps.SpecId=evl.AutoModel</p>
<p>INNER JOIN Product_Series pss with(nolock) ON pss.SeriesId=evl.AutoSeries ORDER BY evlCTE.RowNum ASC;</p>
<h3 id="9-3-3、-求总行数的性能优化"><a href="#9-3-3、-求总行数的性能优化" class="headerlink" title="9.3.3、     求总行数的性能优化"></a>9.3.3、     求总行数的性能优化</h3><p>1、 连接消除</p>
<p>在求总行数是，凡是仅仅是因为显示数据列需要关联的表，就可以不用再关联了。</p>
<p>2、 排序消除</p>
<p>排序是需要很大消耗的，在求总行数时，不需要再用到排序。</p>
<p>3、 与分页数据查询放在同一个查询中执行，这样可以减少网络连接与传输</p>
<p>第一笔数据就是分页数据，比如：第10条到第20条数据，另外一笔数据是当前查询的总记录数，那么我们可以用一个”;”分号进行SQL来实现一次查询取出2笔数据，然后在C#的DataSet对象中分别从Table[0]和Table[1]中取出这2笔不同的数据。</p>
<p>简化后的代码如下：</p>
<p>SELECT COUNT(*)AS TotalCount</p>
<p> FROM Evaluation evl WITH(NOLOCK) WHERE evl.RowStatus=0 AND evl.[AutoSeries]=@id and evl.[EditedFeeling]=1 and evl.[Grade]&gt;-10</p>
<h2 id="9-4-、With-As与性能优化"><a href="#9-4-、With-As与性能优化" class="headerlink" title="9.4  、With As与性能优化"></a>9.4  、With As与性能优化</h2><p>对于SELECT查询语句来说,通常情况下，为了使T-SQL代码更加简洁和可读，在一个查询中引用另外的结果集都是通过视图而不是子查询来进行分解的.但是，视图是作为系统对象存在数据库中，那对于结果集仅仅需要在存储过程或是用户自定义函数中使用一次的时候，使用视图就显得有些奢侈了.</p>
<p>  公用表表达式（Common Table Expression)是SQL SERVER 2005版本之后引入的一个特性.CTE可以看作是一个临时的结果集，可以在接下来的一个SELECT,INSERT,UPDATE,DELETE,MERGE语句中被多次引用。使用公用表达式可以让语句更加清晰简练.</p>
<p>   除此之外，根据微软对CTE好处的描述，可以归结为四点:</p>
<p>·     可以定义递归公用表表达式(CTE)</p>
<p>·     当不需要将结果集作为视图被多个地方引用时，CTE可以使其更加简洁</p>
<p>·     GROUP BY语句可以直接作用于子查询所得的标量列</p>
<p>·     可以在一个语句中多次引用公用表表达式(CTE)</p>
<p>·     注意：如果with as短语被调用了2次以上，CBO会自动将with as 短语的数据放入一个临时表。</p>
<p>在MSDN中的原型：</p>
<p>WITH expression_name [ ( column_name [,…n] ) ] </p>
<p>AS </p>
<p>( CTE_query_definition )</p>
<p>代码示例：</p>
<p><img src="数据表结构的设计与性能优化-1\clip_image053.png" alt="img"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/03/%E3%80%8A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E3%80%8B/">《大型网站技术架构》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%9E%B6%E6%9E%84/">架构</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%AB%98%E6%80%A7%E8%83%BD/">高性能</a></span><div class="content"><!-- MarkdownTOC -->

<ul>
<li><a href="#1-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96">1. 大型网站架构演化</a></li>
<li><a href="#2-%E5%A4%A7%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">2. 大型架构模式</a></li>
<li><a href="#3-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0">3. 大型网站核心架构要素</a></li>
<li><a href="#4-%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84">4. 瞬时响应:网站的高性能架构</a></li>
<li><a href="#5-%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84">5. 万无一失:网站的高可用架构</a></li>
<li><a href="#6-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84">6. 永无止境:网站的伸缩性架构</a></li>
<li><a href="#7-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E6%9E%B6%E6%9E%84">7. 随机应变:网站的可扩展性架构</a></li>
<li><a href="#8-%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E6%9E%84">8. 固若金汤:网站的安全机构</a></li>
</ul>
<!-- /MarkdownTOC -->


<h3 id="1-大型网站架构演化"><a href="#1-大型网站架构演化" class="headerlink" title="1. 大型网站架构演化"></a>1. 大型网站架构演化</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/1%20%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96.png" alt="1. 大型网站架构演化"></p>
<h3 id="2-大型架构模式"><a href="#2-大型架构模式" class="headerlink" title="2. 大型架构模式"></a>2. 大型架构模式</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2%20%E5%A4%A7%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.png" alt="2. 大型架构模式"></p>
<h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3%20%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0.png" alt="3. 大型网站核心架构要素"></p>
<h3 id="4-瞬时响应-网站的高性能架构"><a href="#4-瞬时响应-网站的高性能架构" class="headerlink" title="4. 瞬时响应:网站的高性能架构"></a>4. 瞬时响应:网站的高性能架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/4%20%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84.png" alt="4. 瞬时响应:网站的高性能架构"></p>
<h3 id="5-万无一失-网站的高可用架构"><a href="#5-万无一失-网站的高可用架构" class="headerlink" title="5. 万无一失:网站的高可用架构"></a>5. 万无一失:网站的高可用架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/5%20%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="5. 万无一失:网站的高可用架构"></p>
<h3 id="6-永无止境-网站的伸缩性架构"><a href="#6-永无止境-网站的伸缩性架构" class="headerlink" title="6. 永无止境:网站的伸缩性架构"></a>6. 永无止境:网站的伸缩性架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/6%20%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84.png" alt="6. 永无止境:网站的伸缩性架构"></p>
<h3 id="7-随机应变-网站的可扩展性架构"><a href="#7-随机应变-网站的可扩展性架构" class="headerlink" title="7. 随机应变:网站的可扩展性架构"></a>7. 随机应变:网站的可扩展性架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/7%20%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84.png" alt="7. 随机应变:网站的可扩展性架构"></p>
<h3 id="8-固若金汤-网站的安全机构"><a href="#8-固若金汤-网站的安全机构" class="headerlink" title="8. 固若金汤:网站的安全机构"></a>8. 固若金汤:网站的安全机构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/8%20%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84.png" alt="enter image description here"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/01/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-01</time><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By Garin</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
