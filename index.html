<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Do what you love,Love what you do!"><meta name="keywords" content="大前端,后端,中台,微服务,云原生,企业应用,数字化企业转型等"><meta name="author" content="Garin"><meta name="copyright" content="Garin"><title>进步不是什么事件，而是一种需要。 | 技术之美</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="技术之美" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Garin</div><div class="author-info__description text-center">Do what you love,Love what you do!</div><div class="follow-button"><a href="https://github.com/gengjl">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gitee.com/Jolyon">gitee</a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">技术之美</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">技术之美</div><div id="site-sub-title">进步不是什么事件，而是一种需要。</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/04/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-1/">数据表结构的设计与性能优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">数据库设计</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">SQL性能优化</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DB%E6%9C%8D%E5%8A%A1/">DB服务</a></span><div class="content"><h1 id="1-数据表结构的设计与性能优化"><a href="#1-数据表结构的设计与性能优化" class="headerlink" title="1    数据表结构的设计与性能优化"></a>1    数据表结构的设计与性能优化</h1><h2 id="1-1-、数据表的存储原理"><a href="#1-1-、数据表的存储原理" class="headerlink" title="1.1  、数据表的存储原理"></a>1.1  、数据表的存储原理</h2><p>SQL Server每次读取1个存储块，每个存储块大小为8KB，每读取1个存储块计算为1个逻辑读。</p>
<p>问题：如果数据内容非常大，像我们系统中的Feeling字段非常大，就会导致每个存储块存放的数据行数会非常少，这样当我们读取数据时，要读取许多的存储块。</p>
<p><strong>存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>存储块**</strong>2**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<h2 id="1-2-表设计的优化"><a href="#1-2-表设计的优化" class="headerlink" title="1.2  表设计的优化"></a>1.2  表设计的优化</h2><h3 id="1-2-1、-字段类型优先级"><a href="#1-2-1、-字段类型优先级" class="headerlink" title="1.2.1、     字段类型优先级"></a>1.2.1、     字段类型优先级</h3><p>Bit&gt;int，int&gt;date,time&gt;char,varchar&gt;text，原因：整型，time运算快，节省空间。</p>
<p>所以我们在表设计时，如果是bool类型的数据值就不应该用int类型字段。</p>
<h3 id="1-2-2、-聚集索引字段类型的选择"><a href="#1-2-2、-聚集索引字段类型的选择" class="headerlink" title="1.2.2、     聚集索引字段类型的选择"></a>1.2.2、     聚集索引字段类型的选择</h3><p><img src="clip_image001.png" alt="img"></p>
<p>主键的索引结构中，即存储了主键值，又存储了行数据，这种结构称为“聚集索引”</p>
<p>在插入数据时，数据节点会分裂，这个问题比较严重，节点下存储了“行数据”，分裂的时候，还要移动行数据。如果主键是无规律的，则会加速它的数据节点分裂，且效率极低。</p>
<p>高性能索引策略：</p>
<p>主键，尽量用整型，而且是递增的整型。如果是无规律的数据，将会产生页的分裂，影响速度。索引长度直接影响索引文件大小，影响增删改的速度，并间接影响查询速度（占用内存多）。因为主键索引在物理存放时是有序的，如果主键的值是无序的，那么主键每次插入时，索引文件都重新进行排序，会产生额外的数据消耗，另外主键的叶子上存放的数据，还会导致叶子数据行的移动和分裂，又会产生一些消耗，所以主键尽量用整型，且自增的类型。</p>
<h3 id="1-2-3、-纵向拆分"><a href="#1-2-3、-纵向拆分" class="headerlink" title="1.2.3、     纵向拆分"></a>1.2.3、     纵向拆分</h3><p>纵向拆分方法：把不需要用于查询的大字段，放到另外一个新建的附属表中，如feelingStructured表和Auto表。这样就将Evaluation表的数据内容减少到最少，存储块中可以多存储许多数据行，减少程序读取存储块的个数。</p>
<h3 id="1-2-4、-横向拆分"><a href="#1-2-4、-横向拆分" class="headerlink" title="1.2.4、     横向拆分"></a>1.2.4、     横向拆分</h3><p>横向拆分方法：表分区，表分区的条件，一张数据表的行数至少要达3000W行以上的数据，就可以考虑做表分区了。但这不是绝对，如果表的数据行内容特别多，查询特别慢时，也可以尽早做表分区。</p>
<p>注意问题：普通表在查询时，会比分区表要快一些，因为基于分区表的查询会遍历所有的分区表，而普通表只查询了普通表一个表。</p>
<p>解决办法，在查询条件中加入分区条件，这样查询就会落入指定的分区中，不用遍历所有的分区，但问题是，是不是所有的查询都能加入分区条件呢。只要进行了表分区，那么SQL的前提条件就是所有SQL都要加上分区条件，除非个别的汇总，统计类的SQL。</p>
<h3 id="1-2-5、-数据库分库"><a href="#1-2-5、-数据库分库" class="headerlink" title="1.2.5、     数据库分库"></a>1.2.5、     数据库分库</h3><p>数据库分库：当一个台数据库表服务器访问压力过大，数据量过大时，就需要考虑进行数据库分库，数据库分库条件和表分区的逻辑是比较像的。根据业务条件，如地区，时间，进行拆分。</p>
<h3 id="1-2-6、-读索引为什么比读表快"><a href="#1-2-6、-读索引为什么比读表快" class="headerlink" title="1.2.6、     读索引为什么比读表快"></a>1.2.6、     读索引为什么比读表快</h3><p>这里面引发出一个触类旁通的问题，为什么索引查询会比直接查数据要快？因为索引做为一个独立的数据存储区，也是跟数据表存储块一样，以8KB为一个存储块，一个IO读取一次存储块，而索引中只有简单的几个索引列，而不是整个数据行的数据，所以它一个IO读取的数据会非常多，这样它的IO就会非常少，加快了查询速度。</p>
<h3 id="1-2-7、-数据压缩的利与弊"><a href="#1-2-7、-数据压缩的利与弊" class="headerlink" title="1.2.7、     数据压缩的利与弊"></a>1.2.7、     数据压缩的利与弊</h3><p>数据压缩和索引压缩会使存储空间和逻辑读减少，但是会使表更新的开销加大，查询耗费的CPU也更多，所以压缩表一般适合在更新比较少，且CPU消耗不大，IO消耗很大系统中适用。像企业管理软件就比较适用于数据压缩和BI系统。如果当前系统的IO并不高，但CPU非常繁忙，则不应该采用表和索引压缩，传统数据库的压缩率并不是太高，真正压缩率比较高的应该是BI的数据。</p>
<h1 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2    索引优化"></a>2    索引优化</h1><h2 id="2-1-索引列的设计与优化"><a href="#2-1-索引列的设计与优化" class="headerlink" title="2.1  索引列的设计与优化"></a>2.1  索引列的设计与优化</h2><p>索引列数据的重复度称为可选择性，如性别列的取值范围为”男，女”，这个索引列可选择性就比较低，你在里面能找出太多相同的数据列出来，如选择列数据内容为唯一的，则可选择性非常高。我们选择索引列时，要尽量选择高选择性的列。</p>
<p>案例分析：现在有一个商家黑盒处罚功能，假如商家发布违规的商品和促销信息，则会被系统管理员设置为5天或10天的墨盒状态，墨盒状态期间无法发布商品和促销信息，现在设计有商家黑盒表，有3字段，BusinessID（商家ID）， 生效开始时间（StartTime）、生效结束时间（EndTime），这生效开始时间和生效结束时间2个列谁的选择性高呢？</p>
<p>示例业务数据：</p>
<table>
<thead>
<tr>
<th>BusinessID</th>
<th>StartTime</th>
<th>EndTime</th>
</tr>
</thead>
<tbody><tr>
<td>11111</td>
<td>2014-3-1</td>
<td>2014-3-5</td>
</tr>
<tr>
<td>223333</td>
<td>2015-4-8</td>
<td>2015-4-13-</td>
</tr>
<tr>
<td>23423424</td>
<td>2016-1-13</td>
<td>2016-1-18</td>
</tr>
</tbody></table>
<p>现在找出今天还属于黑盒的商家名单列表</p>
<p>Where startTime&lt;=’2016-1-14’ and EndTime&gt;=’2016-1-14’</p>
<p>大家可以看到，符合startTime&lt;=’2016-1-14’的有3条记录，而符合EndTime&gt;=’2016-1-14’的只有1条记录，所以EndTime的可选择性比StartTime高，这就会决定，我们到底是采用哪一列做索引列，如果2个列都做索引列，哪个索引列会排在前面（多列索引的设计见下面）。</p>
<h2 id="2-2-表扫描查询如何修改为索引列扫描"><a href="#2-2-表扫描查询如何修改为索引列扫描" class="headerlink" title="2.2  表扫描查询如何修改为索引列扫描"></a>2.2  表扫描查询如何修改为索引列扫描</h2><p>如：我们项目中以前用来判断用户是否填写Feeling时，用where len(feeling)&gt;0，len(best)&gt;0，</p>
<p>Len(wrost)&gt;0，</p>
<p>在where条件中用函数会导致表扫描，所以应该设计成标识字段，如IsEditFeeling(bit)，IsWroteBest(bit)，IsWroteWrost(bit)，SQL就可以优化成where IsEditFeeling=1，IsWrostBest=1，IsWroteWrost=1。这样就是索引扫描。</p>
<h2 id="2-3-单列索引的设计与优化"><a href="#2-3-单列索引的设计与优化" class="headerlink" title="2.3  单列索引的设计与优化"></a>2.3  单列索引的设计与优化</h2><p>单列索引设计比较简单，一般就是根据业务条件来定义就行，如根据车系ID或车型ID。但要注意索引列的可选择性。</p>
<h2 id="2-4-多列索引的设计与优化"><a href="#2-4-多列索引的设计与优化" class="headerlink" title="2.4  多列索引的设计与优化"></a>2.4  多列索引的设计与优化</h2><h3 id="2-4-1、-多列索引的存储规则"><a href="#2-4-1、-多列索引的存储规则" class="headerlink" title="2.4.1、     多列索引的存储规则"></a>2.4.1、     多列索引的存储规则</h3><p>假设某个表有一个联合索引(a,b,c)，我们来看下在这个索引中是如何存储这些字段数据的。</p>
<p><img src="clip_image003.jpg" alt="img"></p>
<p><img src="clip_image005.jpg" alt="img"></p>
<h3 id="2-4-2、-多列索引左前缀规则"><a href="#2-4-2、-多列索引左前缀规则" class="headerlink" title="2.4.2、     多列索引左前缀规则"></a>2.4.2、     多列索引左前缀规则</h3><p>多列索引必须用到第1个，否则不生效。</p>
<p><img src="clip_image006.png" alt="img"></p>
<h3 id="2-4-3、-多列索引列的选择优化"><a href="#2-4-3、-多列索引列的选择优化" class="headerlink" title="2.4.3、     多列索引列的选择优化"></a>2.4.3、     多列索引列的选择优化</h3><p>根据以上的多列索引列的存储规则和左前缀规则，在建多列索引时，应该将可选择项高的列放在最左边，后面依次类推，如上面的黑盒案例分析中，应该将endTime列放在最左边，然后才是starttime列。</p>
<p>在选择性相同的情况下，应该把等值（如：=）的放在左边，不等值（如：&gt;，&lt;）放在后面。</p>
<p>Select * from t where object_id&gt;=20 andobject_id&lt;2000 and object_type=’TABLE’;</p>
<p>这个查询对应的索引，应该建成</p>
<p>Create index idx_id_type on t(object_type,object_id);</p>
<h2 id="2-5-书签查找优化"><a href="#2-5-书签查找优化" class="headerlink" title="2.5  书签查找优化"></a>2.5  书签查找优化</h2><p><strong>2.5.</strong>      </p>
<h3 id="2-5-1、-数据表物理存储和索引的物理索引"><a href="#2-5-1、-数据表物理存储和索引的物理索引" class="headerlink" title="2.5.1、     数据表物理存储和索引的物理索引"></a>2.5.1、     数据表物理存储和索引的物理索引</h3><p><img src="clip_image008.jpg" alt="img"></p>
<p><strong>数据存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>数据存储块**</strong>2**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>聚集索引</th>
<th>数据内容</th>
</tr>
</thead>
<tbody><tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
<tr>
<td>聚集索引</td>
<td>数据内容</td>
</tr>
</tbody></table>
<p><strong>索引存储块**</strong>1**<strong>（**</strong>8KB**<strong>）</strong></p>
<table>
<thead>
<tr>
<th>非聚集索引1(include(区))</th>
<th>非聚集索引2</th>
<th>非聚集索引N</th>
</tr>
</thead>
<tbody><tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
<tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
<tr>
<td>非聚集索引1</td>
<td>非聚集索引2</td>
<td>非聚集索引N</td>
</tr>
</tbody></table>
<p>因为索引里面只存储了固定了几列，如果查询时需要读取索引列之外的数据，就需要到数据存储块，根据聚集索引去重新查找我们想要的数据，这就叫书签查找。</p>
<h3 id="2-5-2、-书签查找的缺点"><a href="#2-5-2、-书签查找的缺点" class="headerlink" title="2.5.2、     书签查找的缺点"></a>2.5.2、     书签查找的缺点</h3><p><img src="clip_image010.jpg" alt="img"></p>
<p><img src="clip_image012.jpg" alt="img"></p>
<p>找出书签查找中查找的列</p>
<p><img src="clip_image014.jpg" alt="img"></p>
<h3 id="2-5-3、-书签查找优化"><a href="#2-5-3、-书签查找优化" class="headerlink" title="2.5.3、     书签查找优化"></a>2.5.3、     书签查找优化</h3><p><img src="clip_image016.jpg" alt="img"></p>
<p><img src="clip_image018.jpg" alt="img"></p>
<h2 id="2-6-索引与排序的优化"><a href="#2-6-索引与排序的优化" class="headerlink" title="2.6  索引与排序的优化"></a>2.6  索引与排序的优化</h2><p>索引在物理存储上是有序的，所以如果我们的SQL的排序是基于索引列进行的，那么不需要再重新进行排序，反之，系统会在temp库中建立表变量或临时表，然后在这个表变量或临时表中重新进行排序。如果想为多表联查时，基于多个表做排序字段建立索引，如Order by A.Id,B.Created，则可以基于2个表建立一个物化视图，然后在这个物化视图上为这2列建立索引。</p>
<p>Create index idx_t on t(col1 desc,col2 asc)</p>
<p>Select * from t order by col1 desc,col2 asc</p>
<p>0：sorts(memory)</p>
<p>0：sorts(disk)</p>
<p><img src="clip_image020.jpg" alt="img"></p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 2182 毫秒，占用时间= 231 毫秒。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<p><img src="clip_image022.jpg" alt="img"></p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 0 毫秒，占用时间= 2 毫秒。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<h2 id="2-7-关于索引的坏处"><a href="#2-7-关于索引的坏处" class="headerlink" title="2.7  关于索引的坏处"></a>2.7  关于索引的坏处</h2><p>在有几个索引和情况下和只有主键索引的情况下，插入数据的速度相差10倍，而且数据表里数据记录越大，插入速度越明显。</p>
<p>在无索引的情况下，表的记录越大，插入的速度只会受到很小的影响，基本不会越慢。</p>
<p>在无索引的情况下，分区表的插入要比普通表更慢，因为插入的数据需要做判断，有这方面的开销。</p>
<p>解决办法：读写分离，在主库（或叫写库）上只有主键索引，而没有别的索引。只读库上有许多用于查询的索引，然后写库的数据定时同步到只读库上，这样的话，插入时不会因为索引的原因导致插入变慢，也不会因为没有索引导致查询变慢。</p>
<h2 id="2-8-索引建立时的开销及注意事项"><a href="#2-8-索引建立时的开销及注意事项" class="headerlink" title="2.8  索引建立时的开销及注意事项"></a>2.8  索引建立时的开销及注意事项</h2><p>建索引过程会产生全表锁和建索引过程中会产生全表排序.</p>
<p>后果：普通的对表建索引将会导致针对该表的更新操作无法进行，需要等待索引建完，更新操作将会被建索引的动作阻塞。</p>
<p>解决办法：</p>
<p>CREATE NONCLUSTERED INDEX [IX_Auto_Serial] ON [dbo].[Auto] </p>
<p>(</p>
<p>  [Serial] ASC,</p>
<p>  [RowStatus] ASC</p>
<p>)</p>
<p> WITH ( ONLINE = ON) </p>
<p>在创建索引时，加上online参数，这种建索引的方式不会阻止针对该表的更新操作，与建普通索引相反的是，online建索引的动作是反过来被更新操作阻塞。</p>
<h1 id="3-多表联查优化"><a href="#3-多表联查优化" class="headerlink" title="3    多表联查优化"></a>3    多表联查优化</h1><h2 id="3-1-、字段冗余，不要联查"><a href="#3-1-、字段冗余，不要联查" class="headerlink" title="3.1  、字段冗余，不要联查"></a>3.1  、字段冗余，不要联查</h2><p>业务案例分析：在口碑表里冗余新建一个LastAppendingDrivenKilometers字段，这样就不用关联追加表进行查询了。再冗余新建一个AutoBoughtCity字段，就不用关联Auto表进行查询了。</p>
<h2 id="3-2-、多表联查的实现原理及表关联字段的设计原则"><a href="#3-2-、多表联查的实现原理及表关联字段的设计原则" class="headerlink" title="3.2  、多表联查的实现原理及表关联字段的设计原则"></a>3.2  、多表联查的实现原理及表关联字段的设计原则</h2><p>三大表连接的概要说明：1、Nested Loops Join。2、Hash Join。3、Merge Sort Join</p>
<p>Nested Loops Join驱动结果集的条数决定被驱动表的访问次数</p>
<p>Hash Join两表各自只会访问1次或0次。</p>
<p>Merge Sort Join与Hash Join的相同</p>
<p>表驱动顺序与性能（Nested LoopsJoin性能与驱动顺序有关）</p>
<p>Hash Join性能与驱动顺序有关（和NL相似）</p>
<p>Merge Sort Join性能与表驱动顺序无关</p>
<p><img src="clip_image023.png" alt="img"></p>
<p><img src="clip_image024.png" alt="img"></p>
<p>Nested Loops Join优化要点</p>
<p>1：驱动表的限制条件要有索引。2、被驱动表限制条件要建立索引。3：确保小结果集先驱动，大的被驱动。</p>
<p>Hash Join忧化要点：1：请确保用在全扫描的OLAP场景。2：明确该SQL是否限制Hash Join。3、两表无任何索引倾向HashJoin。第1斧：两表限制条件有索引（看返回量）。第2斧：要小结果集先驱动，大的被驱动。第3斧：尽量保证PGA能容纳Hash运算。</p>
<p>Merge Sort Join优化第1式（两表限制条件有索引）</p>
<p>Merge Sort Join 优化第2式（连接条件索引消除排序，即消除2边分别排序，再合并的这种情况）</p>
<p>因为被驱动表的查询是依赖与ON 条件中写的字段列，如： A join B on A.CID=B.C ID，</p>
<p>那么应该B表的CID设置为索引列，最好设置为聚集索引列，这样关联SQL在运行时，从B表中查找数据时，可以命中索引，否则在B表中查找数据时，会引发表扫描和Hash匹配。</p>
<p>代码示例：</p>
<p>优化前的效果</p>
<p>(1 row(s) affected)</p>
<p>表 ‘Worktable’。扫描计数 0，逻辑读取 0 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘EvaluationPurposeTerms’。扫描计数 1，逻辑读取 1383 次，物理读取 3 次，预读 2269 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘Evaluation’。扫描计数 1，逻辑读取 110 次，物理读取 2 次，预读 80 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>(1 row(s) affected)</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间 = 140 毫秒，占用时间 = 155 毫秒。</p>
<p><img src="clip_image026.jpg" alt="img"></p>
<p>优化后的SQL:</p>
<p>(1 row(s) affected)</p>
<p>表 ‘EvaluationPurposeTerms’。扫描计数 0，逻辑读取 1638 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p>表 ‘Evaluation’。扫描计数 1，逻辑读取 20 次，物理读取 0 次，预读 0 次，lob 逻辑读取 0 次，lob 物理读取 0 次，lob 预读 0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间 = 0 毫秒，占用时间 = 4 毫秒。</p>
<p><img src="clip_image028.jpg" alt="img"></p>
<h2 id="3-3-、关联查询的优化（使用表扫描）"><a href="#3-3-、关联查询的优化（使用表扫描）" class="headerlink" title="3.3  、关联查询的优化（使用表扫描）"></a>3.3  、关联查询的优化（使用表扫描）</h2><p>QualityProblem是一个数据表，QualityProblemDictionary是一个字典表，字典表的数据基本上是固定不变的，大概80行的样子。而在与QualityProblem表关联时，QualityProblem表中符合条件数据的，每一行都会读取一次QualityProblemDictionary字典表。SQL和运行效果如下，现在打算将QualityProblemDictionary字典表一次全读取到内存中，这样就不用每条符合条件的QualityProblem表中数据都去访问QualityProblemDictionary字典表了，修改方法就是在表的Hint中指出不要用索引扫描，要采用表扫描。代码：with(index(0))</p>
<p>SELECT [QualityId] ,[ItemId] AS [ID] ,d.Name ,d.FullName ,d.FullPath ,d.Level ,d.ParentId FROM [QualityProblem] as p with(nolock)</p>
<p>join [QualityProblemDictionary] as d with(nolock) on d.Id = p.ItemId where p.QualityId = 592805 </p>
<p>优化前效果：</p>
<p>(7 row(s) affected)</p>
<p>表’QualityProblemDictionary’。扫描计数7，逻辑读取14 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblem’。扫描计数1，逻辑读取3 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 15 毫秒，占用时间= 23 毫秒。</p>
<p>as d with(index(0),nolock) on d.Id = p.ItemId</p>
<p>优化后效果：</p>
<p>(7 row(s) affected)</p>
<p>表’Worktable’。扫描计数0，逻辑读取0 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblemDictionary’。扫描计数1，逻辑读取19 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p>表’QualityProblem’。扫描计数1，逻辑读取3 次，物理读取0 次，预读0 次，lob 逻辑读取0 次，lob 物理读取0 次，lob 预读0 次。</p>
<p> SQL Server 执行时间:</p>
<p>  CPU 时间= 0 毫秒，占用时间= 2 毫秒。</p>
<h1 id="4-查询计划的缓存与CPU高优化"><a href="#4-查询计划的缓存与CPU高优化" class="headerlink" title="4    查询计划的缓存与CPU高优化"></a>4    查询计划的缓存与CPU高优化</h1><p><strong>1</strong>   </p>
<p><strong>2</strong>   </p>
<p><strong>3</strong>   </p>
<p><strong>4</strong>   </p>
<h2 id="4-1-、概述"><a href="#4-1-、概述" class="headerlink" title="4.1  、概述"></a>4.1  、概述</h2><p>我们SQL执行分为2部分，1是SQL查询计划编译部分，2是SQL运行部分。SQL分析器里显示的CPU时间也是包括编译时间和运行时间。</p>
<p>SQL Server 分析和编译时间: </p>
<p>  CPU 时间= 0 毫秒，占用时间= 0 毫秒。</p>
<p>SQL Server 执行时间:</p>
<p>  CPU 时间= 2668 毫秒，占用时间= 786 毫秒。</p>
<p>因为生成SQL的查询计划是非常耗时和耗CPU的，SQL Server在生成查询计划之后，会将已经生成的查询计划保存到计划缓存中，下次再执行该SQL时不用再重新生成一个全新的计划。</p>
<h2 id="4-2-、如何使查询计划被缓存"><a href="#4-2-、如何使查询计划被缓存" class="headerlink" title="4.2  、如何使查询计划被缓存"></a>4.2  、如何使查询计划被缓存</h2><h3 id="4-2-1、-sp-executesql存储过程"><a href="#4-2-1、-sp-executesql存储过程" class="headerlink" title="4.2.1、     sp_executesql存储过程"></a>4.2.1、     sp_executesql存储过程</h3><p>普通的即席SQL的查询计划是没有被缓存的，通过下面的示例可以看出来。</p>
<p><img src="clip_image029.png" alt="img"></p>
<p><img src="clip_image030.png" alt="img"></p>
<p>通过把SQL改写为用sp_executesql存储过程，即可实现查询计划被缓存。ado.net底层就是把我们写的SQL全部生成sp_executesql sql这种格式的sql，但ado.net无法自动区分我们sql中哪些是参数，哪些不是参数，所以光靠ado.net帮我们自动实现sp_executesql还无法实现查询计划的缓存，还需要我们手动把查询条件参数化写完整。最终实现一个标准的语法</p>
<p>Sp_executesql @sqltext,@param1,,,,,,@paramN</p>
<p><img src="clip_image032.jpg" alt="img"></p>
<p><img src="clip_image033.png" alt="img"></p>
<p><img src="clip_image035.jpg" alt="img"></p>
<p>​      </p>
<h3 id="4-2-2、-存储过程和函数"><a href="#4-2-2、-存储过程和函数" class="headerlink" title="4.2.2、     存储过程和函数"></a>4.2.2、     存储过程和函数</h3><p>存储过程和函数的查询计划也会被缓存。</p>
<h2 id="4-3-、如何解决查询计划不被缓存"><a href="#4-3-、如何解决查询计划不被缓存" class="headerlink" title="4.3  、如何解决查询计划不被缓存"></a>4.3  、如何解决查询计划不被缓存</h2><p>只要采用sp_executesql，存储过程，函数这3种方式写的sql查询计划就会被缓存，但也有原因会导致他们不会被缓存，原因如下：</p>
<p><img src="clip_image037.jpg" alt="img"></p>
<h3 id="4-3-1、-查询计划不被缓存案例示警"><a href="#4-3-1、-查询计划不被缓存案例示警" class="headerlink" title="4.3.1、     查询计划不被缓存案例示警"></a>4.3.1、     查询计划不被缓存案例示警</h3><p>上次线上数据库CPU总是高，从DMV中查到编译数过高，原因是开发人员为线上跟踪代码运行结果和查错方便，在公共数据访问层中，自动为每一条SQL中都加了一条注释，该注释内容为当前系统的Url，因为一个公共方法会被不同模块调用，当前模块的Url自然也是不停的在变，导致SQL的查询计划无法重用。</p>
<h2 id="4-4-、缓存的查询计划什么时候被重新生成"><a href="#4-4-、缓存的查询计划什么时候被重新生成" class="headerlink" title="4.4  、缓存的查询计划什么时候被重新生成"></a>4.4  、缓存的查询计划什么时候被重新生成</h2><p>1、当表数据增长率达到当前数据量的30%时，查询计划会被重编译。</p>
<p>2、当新建和修改索引时。</p>
<p>3、当新建和删除字段时。</p>
<h2 id="4-5-、In条件参数化"><a href="#4-5-、In条件参数化" class="headerlink" title="4.5  、In条件参数化"></a>4.5  、In条件参数化</h2><p>Declare @User1 int;Declare @User2 int;Declare @User3 int;Declare @User4 int;declare @User5 int;</p>
<p>Where userId in(@User1,@User2,@User3,@User4,@User5)</p>
<h1 id="5-并发和阻塞问题"><a href="#5-并发和阻塞问题" class="headerlink" title="5    并发和阻塞问题"></a>5    并发和阻塞问题</h1><p>1、减少事务长度。</p>
<p>2、SQL语句加Nolock。</p>
<p>3、读写分离</p>
<h1 id="6-日志库优化"><a href="#6-日志库优化" class="headerlink" title="6    日志库优化"></a>6    日志库优化</h1><p>当有insert和update,delete操作时，会在日志库中记录日志，随着时间的积累，日志库记录越来越多，每插入一条日志都非常耗时，直接影响我们系统的数据操作。</p>
<p>解决办法：设
